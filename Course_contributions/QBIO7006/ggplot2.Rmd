---
title: "ggplot2 advanced"
author: "St√©phane Guillou"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Refining ggplot2 visualisations

Starting with the `boilrdata` package, let's use the `bunyas` dataset. We will use a number of functions from the tidyverse, so let's also load the whole of the core Tidyverse packages.

```{r boilrdata}
library(boilrdata)
library(tidyverse)
```

The abundance dataset contains counts of 89 species in different locations and different subplots.

We can visualise the data as a kind of heatmap, to try and spot the differences in dominant species and diversity.

The first thing we need to do for a heatmap-like visualisation in ggplot2 is reshape the data to make it tidy: the species names need to be in a column. This can be done with the tidyr package, going from wide format to long format with the `pivot_longer()` function. We can then create a rudimentary grid of coloured cells with ggplot2.

```{r abundances, fig.height=7}
bun_ab <- bunyas$abundances %>% 
  pivot_longer(-c(location, subplot),
               names_to = "species", values_to = "abundance")

bun_ab %>% 
  ggplot(aes(x = paste(location, subplot), y = species, fill = abundance)) +
  geom_tile() +
  theme_minimal()
```

This is very overcrowded, the labels are very hard to read. We can focus on a smaller subset of the data, by removing some of the least common species. To solve the x axis issue, we can opt for splitting the visualisation into facets:

```{r reduce_facet, fig.height=7}
bun_ab <- bunyas$abundances %>% 
  pivot_longer(-c(location, subplot),
               names_to = "species", values_to = "abundance") %>% 
  group_by(species) %>% 
  # filter least abundant species out
  mutate(total = sum(abundance)) %>% 
  filter(total > 4) %>% 
  ungroup()

bun_ab %>% 
  # don't combine the variables for the x axis
  ggplot(aes(x = subplot, y = species, fill = abundance)) +
  geom_tile() +
  # split into facets
  facet_grid(cols = vars(location)) +
  theme_minimal()
```

Next, we can change the colour palette to distinguish values better, sort the rows to have the overall dominant species at the top, and give a logical ordering in the locations.

The [viridis](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html) collection (5 different palettes available) is integrated into ggplot2 and attention was given to accessibility (they print well as grayscale and can be read by people experiencing colourblindness).

For the ordering of rows and column, the forcats package provides handy functions to force a specific order (by converting the variable to a factor) instead of ggplot2's default alphabetical order:

* `fct_inorder()` to conserve the order of the original dataset
* `fct_relevel()` to provide a custom order

```{r factors, fig.height=7}
bun_ab <- bunyas$abundances %>% 
  pivot_longer(-c(location, subplot),
               names_to = "species", values_to = "abundance") %>% 
  group_by(species) %>% 
  mutate(total = sum(abundance)) %>% 
  filter(total > 4) %>%
  arrange(total) %>% # order here...
  ungroup()

bun_ab %>% 
  ggplot(aes(x = subplot,
             y = fct_inorder(species), # ... and keep the order here
             fill = abundance)) +
  geom_tile() +
  scale_fill_viridis_c() +
  facet_grid(cols = vars(
    # provide custom order of levels
    fct_relevel(location,
                c("low_west", "low_east", "mid_west", "mid_east", "high")))
    ) +
  theme_minimal()
```

> Note that we could do a number of things to analyse the data in a more adequate manner, for example using relative abundances, but we focus on the the visualisation here.

Finally, we can customise the labels and reduce the spacing between facets:

```{r looks, fig.height=7}
bun_ab %>% 
  ggplot(aes(x = subplot,
             y = fct_inorder(species),
             fill = abundance)) +
  geom_tile() +
  scale_fill_viridis_c() +
  facet_grid(cols = vars(
    fct_relevel(location,
                c("low_west", "low_east", "mid_west", "mid_east", "high")))
    ) +
  labs(y = "species") +
  theme_minimal() +
  # reduce spacing between facets
  theme(panel.spacing = unit(0, "points"))
```

However, most of the grid is coloured with the lower end of the colour scale. This is because the distribution of the abundance values is very skewed:

```{r abundance_density}
ggplot(bun_ab, aes(x = abundance)) + geom_density()
```

It could be useful to log-transform the colour scale directly, which has the added benefit of making the absence of as species more obvious. We can do that directly in the `scale_*()` function, instead of modifying the underlying data. We then tweak the theme's grid to better guide the audience between species names and coloured cells:

```{r warning=FALSE, fig.height=7, warning=FALSE}
bun_ab %>% 
  ggplot(aes(x = subplot,
             y = fct_inorder(species),
             fill = abundance)) +
  geom_tile() +
  scale_fill_viridis_c(trans = "log10", # transform the colour scale
                       na.value = NA) + # no colour for missing data
  facet_grid(
    cols = vars(
    fct_relevel(location,
                c("low_west", "low_east", "mid_west", "mid_east", "high")))
    ) +
  labs(y = "species") +
  theme_minimal() +
  theme(panel.spacing = unit(0, "points"),
         # remove the x-axis grid
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
```

If you want to fix the cell size ratio, a coordinate function can help. To get a grid of squares, `coord_equal()` will use a default ratio of 1 (but you might have to deal with clipped facet labels).

## Patchwork

Patchwork is a useful package for combining plots, as an alternative to the `grid()` function we have used previously.

It introduces a simple syntax, using operators to combine ggplot2 objects in one layout.

First, let's save our heatmap as an object of class `ggplot`:

```{r heat_as_object, warning=FALSE}
p_heat <- bun_ab %>% 
  ggplot(aes(x = subplot,
             y = fct_inorder(species),
             fill = abundance)) +
  geom_tile() +
  scale_fill_viridis_c(trans = "log10",
                       na.value = NA) +
  facet_grid(
    cols = vars(
    fct_relevel(location,
                c("low_west", "low_east", "mid_west", "mid_east", "high")))
    ) +
  labs(y = "species") +
  theme_minimal() +
  theme(panel.spacing = unit(0, "points"),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
```

Then, create other visualisations, saved as objects. One bar chart about how prominent different families are:

```{r}
# get counts of 5 most common families
top_5_fams <- bunyas$trees %>% 
  count(family, sort = TRUE) %>% 
  slice(1:5)

p_fams <- top_5_fams %>% 
  ggplot(aes(x = n,
             y = fct_inorder(family), # order bars by frequency
             fill = family)) + 
  geom_col() +
  guides(fill = "none") +
  labs(x ="count", y = "family") +
  theme_minimal()
```

And one scatterplot of wood density vs maximum height, in which we join the family data, and define

```{r}
# get species familes from trees dataset
fams <- bunyas$trees %>% 
  select(species, family) %>% 
  unique()

p_traits <- bunyas$traits %>% 
  left_join(fams) %>% # add families into traits dataset
  # add a column that only includes the families to highlight
  mutate(fam_col = if_else(family %in% top_5_fams$family, family, NA_character_)) %>% 
  ggplot(aes(x = wd, y = sqrt_mh)) +
  geom_point(aes(colour = fct_relevel(fam_col, top_5_fams$family))) + # same order as previous plot
  geom_smooth(linetype = "dashed", colour = "black", size = 0.5) +
  scale_colour_discrete(guide = "none", # bar chart will serve as a legend
                        na.value = "lightgrey") + # make other families more discrete
  labs(x = "wood density (fresh mass / dry mass)",
       y = "maximum height (sqrt of m)") +
  theme_minimal()
```

Finally, combine the plots in one single layout:

```{r patchwork, fig.height=8, fig.width=10, warning=FALSE}
library(patchwork)
pw <- (p_fams / p_traits) | p_heat
pw
```

Note that patchwork takes care of aligning the plot areas.

Patchwork provides many tools, including the `&` operator to apply a theme to all plots:

```{r patchwork_theme, fig.height=8, fig.width=10, warning=FALSE}
pw & theme_bw()
```

It also allows annotating each plot, with tags for example:

```{r patchwork_tags, fig.height=8, fig.width=10, warning=FALSE}
pw + plot_annotation(tag_levels = "A")
```

> How could we further improve this combination of plots? Identify issues or annoying details, and try to find solutions in the relevant functions' documentation and online.

## Exporting

RStudio's "Plots" panel has an export menu to save plots to file. However, it does not offer resolution options, and using ggplot2's `ggsave()` function allows automating the process.

By default, it saves the latest plot (but it can also take the object to export as an argument).

```{r eval=FALSE}
ggsave("bunyas.svg")
```

That last command saves the latest visualisation in the Scalable Vector Graphic format, or "SVG". This is an open vector format suitable for further editing in applications like Inkscape or Adobe Illustrator.

For such a large layout of plots, we need larger dimensions:

```{r eval=FALSE}
ggsave("bunyas.svg", width = 28, height = 18, units = "cm")
```

## Custom themes

...

## Interaction with Plotly

...


## Interaction with Shiny

Shiny is a package and framework for creating web applications with R.

An application's structure is divided in two main elements: the **server** (what happens in the background) and the **UI** (the User Interface, in which the user sees and interacts with the content).

In this minimal example, we want to show the user a Plotly visualisation of the relationship between fuel efficiency and size of the engine, using the `mpg` dataset, and let the user control what determines the colour of the points in the scatterplot.

In a single script called `app.R`, we define which packages will be necessary:

```{r eval=FALSE}
# Load the necessary packages
library(shiny)
library(plotly)
```

Then, we define the UI, including:

-   The title
-   The page structure
-   The controls we want to expose to the user
-   The visual output

```{r eval=FALSE}
#### UI ####
ui <- fluidPage(
  # Title
  titlePanel("Fuel efficiency explorer"),
  # Sidebar with a variable selector
  sidebarLayout(
    sidebarPanel(
      selectInput("colour_by",
                  label = "Colour by:",
                  choices = c("Type of car" = "class",
                              "Drive train" = "drv"))
    ),
    # Show the plot
    mainPanel(
      plotlyOutput("scatter")
    )
  )
)
```

We then define what happens on the server:

```{r eval=FALSE}
#### Server ####
server <- function(input, output) {
  
  output$scatter <- renderPlotly({
    # Draw, using the choice provided as an input for colour.
    # Note the use of aes_string()
    p <- ggplot(mpg, aes_string("displ", "hwy",
                                label = "manufacturer", label2 = "model",
                                colour = input$colour_by)) +
      labs(x = "Engine size",
           y = "Fuel efficiency",
           colour = input$colour_by) +
      geom_jitter()
    # Make interactive
    ggplotly(p)
  })
}
```

Finally, we specify how the app should be run, using the `ui` and `server` objects we previously defined:

```{r eval=FALSE}
#### Run the app ####
shinyApp(ui = ui, server = server)
```

> [See the application online](https://stragu.shinyapps.io/shiny_example_1/).

As you test the application online, notice how the code that is run gets highlighted as you select a variable. This demonstrates an important aspect of Shiny apps: their **reactivity**. When a value changes, for example when the user interacts with an input widget, only the section of code that depends on it will be re-run. In our example, the input is used by the ggplot2 code and will therefore be re-run when it changes. Because the `ggplotly()` function depends on the ggplot2 code, it will also be re-run once the `p` object is available.

In this next example, we want to give the option to the user to filter out some values by using a range slider. In the UI, we add another control, a `sliderInput`, which allows the user to select a range of values for the cylinders variable:

```{r eval=FALSE}
      # Range slider is here
      sliderInput("range",
                  label = "Cylinders range:",
                  min = min(mpg$cyl),
                  max = max(mpg$cyl),
                  value = range(mpg$cyl),
                  step = 1)
```

And on the server side, we make use of it just before the plot code, using a `filter()`:

```{r eval=FALSE}
  output$scatter <- renderPlotly({
    p <- mpg %>% 
      # Filter according to the range slider
      filter(between(cyl, input$range[1], input$range[2])) %>% 
      ggplot(aes_string("displ", "hwy",
                        label = "manufacturer", label2 = "model",
                        colour = input$colour_by)) +
      labs(x = "Engine size",
           y = "Fuel efficiency",
           colour = input$colour_by) +
      geom_jitter() +
      geom_smooth(aes(displ, hwy), inherit.aes = FALSE)
    ggplotly(p)
  })
```

> [See the application online](https://stragu.shinyapps.io/shiny_example_2/).

## Further resources

- The book _[Interactive web-based data visualization with R, plotly, and shiny](https://plotly-r.com/)_ by Carson Sievert
- The documentation for both [Plotly](https://plotly.com/r/) and [Shiny](https://shiny.rstudio.com/)

